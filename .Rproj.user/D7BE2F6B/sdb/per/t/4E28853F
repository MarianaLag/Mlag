{
    "contents" : "#' Estimation Nei's Gst parameter\n#' \n#' This function estimates Nei's Gst parameter and potentially\n#'  returns the components of it as well as the probability.  The results are returned\n#'  as a \\code{data.frame}.\n#' @param x  A vector of \\code{\\link{locus}} objects or a \\code{data.frame} with \\code{locus} objects.\n#' @param stratum Either a vector of strata variables if \\code{x} is a \\code{locus} vector or \n#'  the name of the column representing strata in \\code{x} if it is a \\code{data.frame}.\n#' @param nperm The number of permutations to run for significance of the\n#'  estimator.\n#' @param size.correct A flag indicating that the estimate should be corrected for\n#'  based upon sample sizes (default=TRUE).\n#' @return An \\code{data.frame} with Gst, Ht, and Hs and optionally P\n#' @author Rodney J. Dyer \\email{rjdyer@@vcu.edu}\n#' @import ggplot2\n#' @export\n#' @examples\n#'  AA <- locus( c(\"A\",\"A\") )\n#'  AB <- locus( c(\"A\",\"B\") )\n#'  BB <- locus( c(\"B\",\"B\") )\n#'  locus <- c(AA,AA,AA,AA,BB,BB,BB,AB,AB,AA)\n#'  Population <- c(rep(\"Pop-A\",5),rep(\"Pop-B\",5))\n#'  Gst( locus, Population, nperm=99 )\n#'  locus2 <- c(AB,BB,AA,BB,BB,AB,AB,AA,AA,BB)\n#'  df <- data.frame( Population, TPI=locus, PGM=locus2 )\n#'  Gst( df, nperm=99)\nGst <- function( x, stratum=\"Population\", nperm=0, size.correct=TRUE ) {\n  \n  # Do this function recursively if a data.frame is passed as loci\n  if( is(x,\"data.frame\") ) {\n    \n    locus_names <- column_class(x,\"locus\")\n    \n    if( length(locus_names)==0 )\n      stop(\"You must pass some loci to this function\")\n    \n    if( !(stratum %in% names(x)) )\n      stop(\"If you pass a data.frame to Gst(), you need to indicate a stratum varaible column.\")\n    \n    strata <- factor( as.character( x[[stratum]]))\n    K <- length(locus_names)\n    ret <- data.frame(Locus=locus_names, Gst=numeric(K), Hs=numeric(K), Ht=numeric(K), P=numeric(K), stringsAsFactors=FALSE)\n\n    for( i in 1:length(locus_names) ){\n      data <- x[[locus_names[i]]] \n      r <- Gst( data, strata, nperm, size.correct)\n      ret[i,2:5] <- r\n    }\n    \n    if( length(locus_names) > 1 ) {\n      Hs.tot <- sum(ret$Hs, na.rm=TRUE )\n      Ht.tot <- sum(ret$Ht, na.rm=TRUE )\n      Gst.tot <- 1 - Hs.tot / Ht.tot\n      \n      ret[K+1,1] <- \"Multilocus\"\n      ret[K+1,2] <- Gst.tot\n      ret[K+1,3] <- Hs.tot\n      ret[K+1,4] <- Ht.tot      \n    }\n\n  }\n  \n  # do this for a single locus\n  else {\n    \n    if( !is( x, \"locus\") )\n      stop(paste(\"This function requires objects of type 'locus' to function, you passed a '\", class(x), \"' object\",sep=\"\" ))\n    \n    if( !is( stratum, \"factor\") )\n      stratum <- factor( as.character(stratum ))\n    \n    if( length(x) != length(stratum) )\n      stop(\"You must pass loci and strata vectors of the same length to Gst().\")\n    \n    k <- length( levels( stratum ) )\n    strata.lvls <- levels( stratum )\n    \n    totfreq <- frequencies( x )\n    inds <- to_mv.locus( x )\n    p.vec <- colSums( inds )\n    \n    ht <- 1-sum( (p.vec / sum( p.vec ) )^2 )\n    hs <- mean(unlist(lapply( strata.lvls, \n                              function(strat,inds,strata ) {\n                                s <- colSums(as.matrix(inds[strata==strat,]))\n                                f <- 1-sum((s/sum(s))^2)\n                                return(f)\n                              }, inds=inds, strata=stratum)), na.rm=TRUE )\n    \n    if( ht == 0 ) {\n      gst <- NA\n      ht.estimated <- 0\n      hs.estimated <- 0\n    }\n    \n    else if( size.correct ) {\n      n.harmonic <- 1/mean(1/table(stratum))\n      hs.estimated <- (2*n.harmonic)/(2*n.harmonic -1) * hs\n      ht.estimated <- ht + hs.estimated/(2*k*n.harmonic)\n      gst <- 1-hs.estimated/ht.estimated    \n    }\n    \n    else {\n      gst <- 1-hs/ht\n      hs.estimated <- hs\n      ht.estimated <- ht\n    }\n    \n    \n    \n    \n    \n    if( nperm > 0 & ht > 0 ) {\n      perms <- rep(NA,nperm)\n      for(i in 1:nperm ) {\n        hs.perm <- lapply( strata.lvls, \n                           function(strat,inds,strata ) {\n                             s <- colSums(as.matrix(inds[strata==strat,]) )\n                             f <- 1 - sum((s/sum(s))^2) \n                           }, \n                           inds=inds, \n                           strata=sample(stratum))\n        perms[i] <- mean(unlist(hs.perm))\n      }\n      if( size.correct ) {\n        perms <- (2*n.harmonic) / (2*n.harmonic-1) * perms\n        perms <- 1 - perms/ht.estimated      \n      }\n      else\n        perms <- 1 - perms/ht\n      \n      perms <- perms[ !is.na(perms) ]\n      P <- sum( perms >= gst ) / length(perms)\n\n    }\n    else \n      P <- NA\n    \n    ret <- data.frame( Gst=gst, Hs=hs.estimated, Ht=ht.estimated, P=P)\n    \n\n  }  \n  return( ret ) \n}\n\n\n",
    "created" : 1383753040866.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3820822544",
    "id" : "4E28853F",
    "lastKnownWriteTime" : 1384532949,
    "path" : "~/Documents/Dropbox/R/gstudio/gstudio/R/gst.R",
    "project_path" : "R/gst.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}