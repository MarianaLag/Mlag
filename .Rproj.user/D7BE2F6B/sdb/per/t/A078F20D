{
    "contents" : "#' Produces offspring\n#' \n#' This function is mostly for simulation work and functions to \n#'  produce a set of offpsring for the individuals passed.\n#' @param mom  This is the 'maternal' individual in that all the\n#'  metadata in the \\code{data.frame} that describes this individual \n#'  will be transfered to the offspring.\n#' @param dad This is the 'paternal' individual and will contribute only\n#'  half of its genetic compliement to the offspring.\n#' @param N The number of offspring to produce.\n#' @param ID The column in \\code{mom} that is the identification column\n#'  as all offspring from a maternal individual have the same ID (see also\n#'  \\code{\\link{paternity}} and \\code{\\link{minus_mom}}).\n#' @param stratum An optional argument that allows you to pass a column\n#'  name to work as a stratum variable.  This will cause the function to \n#'  break the data into populations first to do mating.\n#' @return A \\code{data.frame} of offspring.\n#' @note If only a \\code{data.frame} is passed to as 'mom' and the rest are\n#'  left out, by default the code will do a complete random mating (no inbreeding)\n#'  process for you keeping the same population size as the data you passed it.  \n#'  This is nice for iterating across generations in simulation work.\n#' @export\n#' @author Rodney J. Dyer \\email{rjdyer@@vcu.edu}\n#' @examples\n#' f <- data.frame(Allele=LETTERS[1:2], Frequency=c(0.5,0.5))\n#' adults <- make_population(f,N=2)\n#' adults\n#' mate( adults[1,], adults[2,], N=10)\nmate <- function( mom, dad, N, ID=\"ID\",stratum=NULL){\n  \n  # mates individuals within populations\n  if( !is.null( stratum ) ){\n    pops <- partition(mom,stratum)\n    ret <- data.frame()\n    for(pop in pops){\n      tmp <- mate( pop, ID=ID, N=N )\n      ret <- rbind( ret, tmp)\n    }\n  }\n  \n  # mates a whole population by keeping it the same size\n  else if( !missing(mom) & nrow(mom)>1 & missing(dad) ){\n    ret <- mom\n    for( i in 1:N ) {\n      for( locus in column_class(ret,\"locus\")){\n        idx <- sample(1:N, size=2)\n        ret[[locus]][i] <- mom[[locus]][idx[1]] + mom[[locus]][idx[2]]\n      }\n    }\n  }\n\n  else {\n    \n    if( missing(mom) | missing(dad) )\n      stop(\"You need to pass both parents to make an offspring using mate().\")\n    if(missing(N))\n      stop(\"You need to specify how many offspring to make using mate().\")\n    \n    locus_names <- column_class(mom,\"locus\")\n    offnames <- setdiff( names(mom), locus_names)\n    offnames <- c(offnames, \"OffID\")\n    \n    ret <- data.frame( ID=rep(mom[[ID]], N), OffID=seq(1,N) )\n    \n    # add the other metadata\n    for( item in offnames)\n      if( item != ID & item != \"OffID\")\n        ret[[item]] <- mom[[item]]\n    \n    # add the loci as NA\n    for( locus in locus_names) \n      ret[[locus]] <- NA\n    \n    \n    # add the loci\n    for( locus in locus_names){\n      l <- rep(NA,N)\n      for( i in 1:N)\n        l[i] <- mom[[locus]] + dad[[locus]]\n      ret[[locus]] <- locus( l, type=\"separated\")\n    }\n    \n  }\n  \n  \n  return( ret )\n}\n\n",
    "created" : 1382442216858.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3765599771",
    "id" : "A078F20D",
    "lastKnownWriteTime" : 1382447872,
    "path" : "~/Documents/Dropbox/R/gstudio/gstudio/R/mate.R",
    "project_path" : "R/mate.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}