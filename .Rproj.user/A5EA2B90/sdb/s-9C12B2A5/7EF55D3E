{
    "contents" : "#' General constructor for locus object\n#' \n#' This function creates an object of type \\code{locus}, a fundamental\n#'  type in the gstudio package.  Therea re several kinds of loci that\n#'  can be created.\n#' @param x The data to be turned into a \\code{locus} object\n#' @param type An indication of what kind of data it is.  By default this\n#'  parameter is missing and this will cause the function to assume that \n#'  every element of x is an allele in the genotype.\n#'  \\itemize{\n#'    \\item{blank}{Default value, uses all passed items as alleles}\n#'    \\item{aflp}{Encoded as 0,1 for absence/presence of bands.}\n#'    \\item{column}{Two columns of alleles}\n#'    \\item{separated}{Pre-separated alleles (with ':').}\n#'    \\item{snp}{Encoded by the number of minor alleles at the locus.}\n#'    \\item{zyme}{Alleles like zymes (e.g., 12 for '1' and '2' alleles).}\n#' }\n#' @param phased A flag indicating the the alleles should are of\n#'  known gametic phase (default=FALSE).\n#' @return Either a single or vector of objects of type \\code{locus}.\n#' @author Rodney J. Dyer \\email{rjdyer@@vcu.edu}\n#' @export\n#' @examples\n#' AA <- locus( c(\"A\",\"A\") )\n#' AB <- locus( c(\"A\",\"B\") )\n#' BB <- locus( c(\"B\",\"B\") )\n#' AC <- locus( c(\"A\",\"C\") )\n#' AD <- locus( c(\"A\",\"D\") )\n#' BC <- locus( c(\"B\",\"C\") )\n#' BD <- locus( c(\"B\",\"D\") )\n#' CC <- locus( c(\"C\",\"C\") )\n#' CD <- locus( c(\"C\",\"D\") )\n#' DD <- locus( c(\"D\",\"D\") )\n#' loci <- c(AA,AB,AC,AD,BB,BC,BD,CC,CD,DD) \n#' loci\nlocus <- function( x, type, phased=FALSE ){\n  \n  # missing data\n  if( missing(x) || (length(x)==1 & nchar(x)==0) )\n    ret <- \"\"\n  \n  # default, sort and collapse em.\n  else if( missing(type) ){  \n    ret <- as.character(x)\n    if( any(nchar(ret))) {\n      if( !phased )\n        ret <- sort(ret)\n      ret <- paste(ret,collapse=\":\")\n      if( ret == \"NA:NA\")\n        ret <- \"\"\n    }\n  }\n  \n  # aflp\n  else if( type == \"aflp\" ){\n    if( length(x) > 1 ) \n      ret <- unlist(lapply(x,function(x) locus(as.character(x),type=\"aflp\"))) \n    else if( !(x %in% c(\"0\",\"1\")) )\n      ret <- \"\"\n    else\n      ret <- x\n  }\n  \n  else if( type == \"snp\"){\n    if( length(x) > 1 )\n      ret <- unlist(lapply(x,function(x) locus(as.character(x),type=\"snp\")))\n    else \n      ret <- switch( as.character(x),\"0\"=c(\"A:A\"),\"1\"=c(\"A:B\"),\"2\"=c(\"B:B\"),\"\")\n  }\n  \n  #column types\n  else if( type == \"column\") \n    ret <- apply( x, 1, function(x) locus(as.character(x), phased=phased))\n  \n  \n  else if( type == \"separated\" ) {\n    if( length(x) > 1)\n      ret <- unlist(lapply(x,function(x) locus(x)))\n    else {\n      if( x == \"NA:NA\" || x == \"NA\")\n        ret <- \"\"\n      else \n        ret <- locus( strsplit( x, split=\":\")[[1]], phased=phased)\n    }\n      \n  } \n  \n  else if( type == \"zyme\" ){\n    \n    if( length(x) > 1 )\n      ret <- unlist( lapply(x, function(x) locus(x,type=\"zyme\")))\n    else {\n      N <- nchar(x)\n      n <- N/2\n      l <- substr(x,1,n)\n      r <- substr(x,(n+1),N)\n      ret <- locus(c(l,r))\n    }\n  }\n  \n  \n  class(ret) <- \"locus\"\n  return(ret)\n}\n\n\n\n\n\n##########################################################################\n#                                                                        #\n#                       Extending S3 Methods                             #\n#                                                                        #\n##########################################################################\n\n\n#' Converts locus to a list\n#' \n#' This converts a \\code{locus} object into a \\code{list} so that\n#'  you can use \\code{locus} objects in a column of a \\code{list}.\n#' @param x An object of type \\code{locus}.  This can be either a single genotype \n#'  (a rare case) or a vector of genotypes (preferred). \n#' @param \\dots Additional objects that are passed to \\code{as.data.frame.vector}.\n#' @return A \\code{list} object.\n#' @method as.list locus\n#' @export\n#' @author Rodney J. Dyer \\email{rjdyer@@vcu.edu}\n#' @examples\n#' \n#' loc1 <- c( locus(1:2), locus(1:2), locus( c(1,1) ) )\n#' df <- as.list( ID=1:3, NAMED_LOCUS=loc1, loc1 )\n#' df\n#'\nas.list.locus <- function( x, ... ) {\n  ret <- list()\n  for( i in 1:length( x )) { \n    ret[[i]] <- x[i]\n  }\n  ret\n}\n\n\n\n#' As operator for locus\n#' \n#' This takes several things and shoves it into the constructor\n#' @param x An object that is to be truned into a \\code{locus}.\n#' @return An object of type \\code{locus}\n#' @export\n#' @author Rodney J. Dyer \\email{rjdyer@@vcu.edu}\n#' @seealso \\code{\\link{locus}}\n#' @examples\n#' \n#' lst <- list( \"A\", \"B\" )\n#' as.locus( lst )\n#' vec <- 1:2\n#' as.locus( lst )\n#' chr <- \"A\"\n#' as.locus( chr )\n#' chr.sep <- \"A:A\"\n#' as.locus( chr )\n#' \nas.locus <- function( x ) {\n  return( locus(x) )\n}\n\n\n\n#' Concatinate \\code{locus} objects\n#' \n#' An overload of the \\code{c} function for \\code{locus} objects.\n#' @param \\dots The \\code{locus} objects to be concatenated.\n#' @param recursive A flag to do the concatenation recursively.\n#' @return A vector of \\code{locus} objects\n#' @method c locus\n#' @export\n#' @author Rodney J. Dyer \\email{rjdyer@@vcu.edu}\n#' @examples\n#' \n#' loci <- c( locus(1:2), locus(1:2), locus( c(1,1) ) )\n#' loci\n#' \nc.locus <- function(..., recursive = FALSE) {\n  dots <- list(...)\n  classes <- rep(\"locus\", length(dots))\n  res <- structure(unlist(dots, recursive = recursive), class = classes)\n  class(res) <- \"locus\"\n  res\n}\n\n\n\n\n#' Overload of \\code{print} function for \\code{locus} objects\n#' \n#' Prints out the \\code{locus} to stdout.\n#' @param x The \\code{locus} object\n#' @param \\dots Other arguments passed to \\code{\\link{print.default}}.\n#' @return Nothing\n#' @method print locus\n#' @export\n#' @author Rodney J. Dyer \\email{rjdyer@@vcu.edu}\n#' @examples\n#' \n#' loc <- locus( 1:2 )\n#' print( loc )\n#' \nprint.locus <- function(x, ... ) {\n  x0 <- unlist( lapply( x, as.character ) )\n  x0[x0==\"NA\"] <- NA\n  x0[nchar(x0)==0] <- NA\n  print.default(x0,...)\n  invisible(x0)\n}\n\n\n\n\n\n\n\n#' Provides a summary of the \\code{locus} object\n#' \n#' Provides an overload of the \\code{summary} object so that when you\n#'  put this into a \\code{data.frame} and ask for a summary, it will \n#'  provide you a summary of genotype counts.\n#' @param object The \\code{locus} object to summarize (typically a vector).\n#' @param \\dots Ignored\n#' @return A summary of the vector of \\code{locus} objects in \\code{object}\n#' @method summary locus\n#' @export\n#' @author Rodney J. Dyer \\email{rjdyer@@vcu.edu}\n\nsummary.locus <- function(object,...) { \n  genos <- paste(as.character( object ), \" \", sep=\"\")\n  genos[ genos==\" \" ] <- NA\n  return( summary(factor(genos),maxsum=7))\n}\n\n\n\n\n\n#' An 'is-a' operator for \\code{locus}\n#' \n#' A quick convienence function to determine if an object is\n#'  inherited from the \\code{locus} object.\n#' @param x An object to query\n#' @return A logical flag indicating if \\code{x} is a type of \\code{locus}\n#' @export\n#' @author Rodney J. Dyer \\email{rjdyer@@vcu.edu}\n#' @examples\n#' \n#' loc1 <- locus( c(\"A\",\"A\") )\n#' is.locus( loc1 )\n#' is.locus( FALSE )\n#' is.locus( 23 )\n#' \nis.locus <- function ( x ) { \n  return( inherits(x,\"locus\"))\n}\n\n\n\n\n\n#' Overload '[' for vectors of \\code{locus} objects\n#' \n#' An overload of the \\code{[} function for \\code{locus} objects.\n#' @param x An object of type \\code{locus}\n#' @param i The index of the allele to grab.\n#' @return The allele at the ith position.\n#' @rdname locus-operator-index\n#' @method [ locus\n#' @export\n#' @author Rodney J. Dyer \\email{rjdyer@@vcu.edu}\n#' @examples\n#' \n#' loci <- c( locus(1:2), locus(1:2), locus( c(1,1) ) )\n#' loci[2]\n#'\n`[.locus` <- function (x, i) {\n    y <- unclass(x)[i]\n    class(y) <- \"locus\"\n    return(y)  \n}\n\n\n\n\n\n#' Overload '+' operator for pairs of \\code{locus} objects\n#' \n#' An overload of the \\code{+} operator for \\code{locus} objects that\n#'  results in the creation of an offspring \\code{locus}.\n#' @param e1 A \\code{locus} object.\n#' @param e2 A \\code{locus} object.\n#' @return A new \\code{locus} object that represents an offspring \n#'  genotype.\n#' @rdname locus-operator-plus\n#' @method + locus\n#' @export\n#' @author Rodney J. Dyer \\email{rjdyer@@vcu.edu}\n#' @examples\n#' \n#' dad <- locus( c(\"A\", \"A\") ) \n#' mom <- locus( c(\"B\", \"B\") )\n#' off <- mom + dad \n#' off\n#'\n`+.locus` <- function( e1, e2 ){\n  if( is.na(e1) || is.na(e2))\n    stop(\"Cannot add missing locus objects.\")\n  \n  a1 = alleles(e1)\n  a2 = alleles(e2)\n  if( length(a1)!=length(a2))\n    stop(\"Cannot add genotypes with different ploidy levels.\")\n  if( length(a1)<2 || length(a2)<2 )\n    stop(\"Cannot add genotypes less than diploid\")\n  if( length(a1) %% 2 )\n    stop(\"General addition is not supported for odd ploidy (too many assumptions), \n         you can write your own routine.\")\n  n <- length(a1)/2\n  off <- locus(  c( sample(a1, size=n, replace=FALSE),\n                   sample(a2, size=n, replace=FALSE)))\n  return(off)\n}\n\n\n\n\n#' Overload '-' operator for pairs of \\code{locus} objects\n#' \n#' An overload of the \\code{-} operator for \\code{locus} objects that\n#'  removes the contribution of a parental genotype to a offspring \n#'  genotype (if possible).\n#' @param e1 A \\code{locus} object reprenting the offspring.\n#' @param e2 A \\code{locus} object representing the parent.\n#' @return A new \\code{locus} object that represents the genotypes\n#'  left over after removing the parental part (if possible).\n#' @note In some cases it is not possible to remove parental alleles (e.g., \n#'  consider cases where both parent and offspring are the same \n#'  heterozygote).\n#' @rdname locus-operator-minus\n#' @method - locus\n#' @export\n#' @author Rodney J. Dyer \\email{rjdyer@@vcu.edu}\n#' @examples\n#' \n#' mom <- locus( c(\"A\", \"A\") ) \n#' off <- locus( c(\"A\", \"B\") )\n#' dad.gamete <- off - mom\n#' dad.gamete\n#'\n`-.locus` <- function( e1, e2 ){\n  \n  \n  if( length(e1) > 1 ){\n    ret <- locus()\n    for( i in 1:length(e1)){\n      ret <- c( ret, e1[i] - e2[i] )\n    }\n    return( ret[-1] )\n  }\n  \n  \n  if( is.na(e1) || is.na(e2)) {\n    warning(\"Subtract missing locus objects.  Nothing subtracted.\")\n    return( e1 )\n  }\n    \n  \n  off <- alleles(e1)\n  mom <- alleles(e2)\n  if( length(off)!=length(mom))\n    stop(\"Cannot subtract genotypes with different ploidy levels.\")\n  if( length(off)<2 || length(mom)<2 )\n    stop(\"Cannot subtract genotypes less than diploid\")\n  if( length(off) %% 2 )\n    stop(\"General subtraction is not supported for odd ploidy (too many assumptions), \n         you can write your own routine.\")\n  \n  # mother and offspring both same\n  if( e1 == e2 ){\n    \n    # cant reduce heterozygotes\n    if( is_heterozygote(e1))\n      return(e1)\n    \n    # homozygote, return half of the offspring alleles\n    else\n      return( locus(off[1:(length(off)/2)]))\n  }\n  \n  else { \n    \n    int <- intersect(off,mom)\n    \n    # mother alleles not in offspring or not having half of the alleles\n    if( length(int) == 0 ) {\n      message(paste(\"Unable to subtract adult '\",e2,\"' from offspring '\",e1,\n                    \"', result is unreduced.\",sep=\"\"))\n      return(e1)\n    }  \n    \n    # mother and offspring different\n    else {\n      mom_allele <- which( off==int)[1]\n      offidx <- 1:length(off)\n      \n      ret <- locus( off[ offidx[ offidx != mom_allele]])\n      return(ret) \n    }\n  }\n  \n   \n}\n\n\n\n",
    "created" : 1394787390389.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2729153579",
    "id" : "7EF55D3E",
    "lastKnownWriteTime" : 1388929263,
    "path" : "~/Documents/Dropbox/R/gstudio/gstudio/R/locus.R",
    "project_path" : "R/locus.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}