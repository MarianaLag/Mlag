<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Using gstudio}
-->

<link href="http://dyerlab.bio.vcu.edu/media/dyerlab.doc.css" rel="stylesheet"></link>

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(out.extra='style="display:block; margin: auto"', fig.align="center")
```



# An Introduction to the **gstudio** Package


## Package Overview

The **gstudio**  package is a package created to make the inclusion of marker based population genetic data in the R workflow easy.  An underlying motivation for this package is to provide a link between spatial analysis and graphing packages such that the user can be quickly and easily manipulate data in exploratory ways that aid in gaining biological inferences.




### Installing the package

This package requires several other packages for installation.  By default, the install should be easily accomplished using the build-in functionalities in R.

```{r, eval=FALSE,echo=TRUE}
install.packages("gstudio")
```

Occassionally, you should look to see if there are updates to the package by doing the following (this will update all packages you have installed)

```{r, eval=FALSE}
update.packages( ask=FALSE )
```


### Loading the Package

And any time you need to use the package, you would just pull it into your session.

```{r,message=FALSE}
require(gstudio, quietly=TRUE)
```

This should get you everything you need. The **gstudio**  package does contain a lot of build-in documentation including a lot of examples.  All the functions and examples associaed with them can be found in the build-in documents available from:


```{r, eval=FALSE}
help(package="gstudio")
```

At any point if you have any questions about the values or options for a particular function in **gstudio**  or any other package, you can use the  *help.search(func)* or *?* functionality.This file is also kept in sync with the development of the **gstudio**  package (it is in the source packge that you downloaded from CRAN) and will serve as a tutorial for your use of this package.  If there are any questions that you may have regarding this package, feel free to contact [Rodney Dyer](mailto://rjdyer@vcu.edu) and I will get back to you as soon as possible.



---



## Genetic Data 

The overriding philosophy behind the **gstudio**  package is to make it as easy as possible to create, load, use, and integrate, genetic marker data into your analysis workflow.  As such, we typically use *data.frame* objects to hold our data and the addition of the `locus` class as a fundamental data type allows us to continue to do so.

```{r}
x <- locus( c(1,2) )
class(x)
x
```


You can think of a *locus* object as a vector of alleles.  There are several options you can use when constructing a *locus* object based upon what kind of marker data you are using.  These options are passed through the `type` option to the `locus()` function.  Here are the current options.

`type` Option | Function
------------- | ---------
              | This is the default value (e.g., nothing passed). It will treat the values passed to locus as alleles to a single locus
`snp`         | Alleles are `0`, `1`, or `2` indicating the number of minor alleles.
`zyme`        | Genotypes are encoded as "12" like zymes (e.g., "1" & "2" alleles together).
`separated`   | Alleles are already separated by ":" character (for putting in polyploid data)
`column`      | Alleles for a single locus are in two separate columns.

Here is some examples.

```{r}
loc0 <- locus( )
loc1 <- locus( 1 )
loc2 <- locus( c("C","A"), phased=TRUE )
loc3 <- locus( c("C","A") )
loc4 <- locus( 12, type="zyme" )
loc5 <- locus( 1:4 )
loc6 <- locus( "A:C:C:G", type="separated" )
loci <- c(loc0, loc1, loc2, loc3, loc4, loc5, loc6 )
loci
```

Notice how the printing of each `locus` object uses the colon character to separate alleles.  Also, since the `locus` object is a basic data type, it can be used in other data structures.

```{r}
df <- data.frame( ID=0:6, Loci=loci )
df
```

And you can use normal vector processing of the locus vector to do normal R data like operations.

```{r}
is.na( df$Loci )
is.heterozygote( df$Loci )
```



### Saving and Loading Data

Saving data once it is in R is trivial and you do it as you would for any other R object.  The R object system knows how to serialize its own data using the *load()* and *save()* functions.

```{r,eval=FALSE}
save(df, file="MyData.rda")
```

To load the objects back into the workspace, you just do:

```{r,eval=FALSE}
load("MyData.rda")
```

And you can verify that you have data in your workspace by listing it.

```{r}
ls()
```





### Importing Data

Importing data is not that difficult.  People tend to keep their data in spreadsheets or text files, which are easily accessable via R.  For genetic marker data **gstudio**  has a particular function, *read.population()* that is a mix between the traditional *read.table()* function and the *locus()* functions.  Options for this function include:

Option        |    Function
------------- | --------------
path          | The full path to the text file
type          | The locus `type` (see above).
locus.columns | A vector of numbers of columns to be treated as *Locus()* objects
sep           | The character used to separate columns (',' is default)
header        | Columns have header names (e.g., locus names, etc.)

Here are some examples of data files with different kinds of genetic data, each of which exercises the `read.population()` function in a different way.  Hopefully this covers the main types of data being imported, if not, drop me an email [Rodney Dyer](rjdyer@vcu.edu).  Missing genotypes should be missing data or encoded as `NA`.  If you do not have a genotype then leave it blank.  There is no reason to use negative numbers or other conventions.  

Columns of genotypes are indicated by the required parameter `locus.columns` so that `read.population()` knows which columns to treat as `locus` objects and which to leave as normal data for R.  Without this parameter, the data will be read in as `character` or `numeric`.

There are some example data files included in the project for you to look at. Depending upon how your computer is set up, they may be placed in different locations.  Here is a quick way to find out where the installed folder is for the **gstudio** package and the location of the 'data' folder within it.

```{r}
system.file("extdata",package="gstudio")
```


#### Two Column Data

Here is an example of data where the genotypes are encoded as two columns of data in a csv file.  

```{r}
file <- system.file("extdata","data_2_column.csv",package="gstudio")
data <- read.population(file,type="column", locus.columns=4:7)
data
```


#### Phased Data

There are times when the gametic phase of the genotypes is important.  By default, **gstudio** will keep alleles sorted in alpha/numeric order.  If you need to keep this from happening, pass the optional `phased` option to `read.population()`.  Notice the differences between this and the previous genotypes.

```{r}
file <- system.file("extdata","data_2_column.csv",package="gstudio")
data <- read.population(file,type="column", locus.columns=4:7, phased=TRUE)
data
```




#### AFLP-like data

Genotypes that are 'aflp'-like are encoded as binary characters (e.g., 0/1) indicating the presence or absence of a paraticular band.  

```{r}
file <- system.file("extdata","data_aflp.csv",package="gstudio")
data <- read.population(file,type="aflp", locus.columns=c(4,5))
data
```


#### SNP Minor Allele Data

At times, SNP data is encoded in relation to the number of minor alleles.  You can import these data using the `type="snp"` option and it will encode them as 'AA', 'AB', or 'BB' with the 'B' allele as the minor one.

```{r}
file <- system.file("extdata","data_snp.csv",package="gstudio")
data <- read.population(file,type="snp", locus.columns=4:7)
data
```

#### Zyme-Like Data

Some data is encoded as allozyme genotypes (e.g., 33, 35, 55 for dipoid individuals with alleles '3' and '5').

```{r}
file <- system.file("extdata","data_zymelike.csv",package="gstudio")
data <- read.population(file,type="zyme", locus.columns=4:7)
data
```



#### Pre-Separated Data For Higher Ploidy

```{r}
file <- system.file("extdata","data_separated.csv",package="gstudio")
data <- read.population(file,type="separated", locus.columns=c(4,5))
data
```





### Datasets in the Package

The main genetic data included with the package if from the Sonoran desert bark beetle, *Araptus attenuatus* from the Dyer laboratory.  You can load it into your workspace by:


```{r}
data(arapat)
summary(arapat)
```

You can see several things here.  First, the locus data are displayed by genotype counts including NA values where there was missing data.  A column of type `locus` is just like any other kind of variable and can be used as such.  This opens up a lot of functionality for you to be able to treat marker data just like everything else in R.

### Convenience Functions

Dealing easily with parts of your data is a critical skill and a huge benefit in using a grammar like R to do your analyses.  In R, *data.frame* objects are almost like little databases and you can do some really creative manipulations with them. The **gstudio**  package provides a few things that may help you work more efficiently with your data.



#### Data Classes

Often it is important to know which columns of a data set are actually of a particular data type.  Here is a simple function that tells you either the name or index of columns in a data.frame that of a specific data type.

```{r}
column_class( arapat, class="locus")
column_class( arapat, class="locus", mode="index" )
```

#### Partitioning

The *Partition()* function takes a data frame and returns a list of data frames, partitioned by the stratum you pass to it.  This is really nice if you are doing a nested analysis of sorts and want to work with subsets of your data that are defined by a categorical *factor* variable.

```{r}
names(arapat)
clades <- partition( arapat, stratum="Species")
names( clades )
```


### Plotting Populations

One of the key benefits to using an analysis environtment such as R is that you can mash together functionality that you just can't get from a monolithic program.  An example of this is plotting populations.  If your data has spatial coordinates in them then you can use this to plot the location of your sites on a GoogleMap tile.  By default, you **must** have your coordinates in decimal degree format.  This is the default for the GoogleMaps API.  Moreover, if you name the columns of data "Longitude" and "Latitude" much of the spatial functionality in **gstudio** will be more transparent (if not, you have to specify the Longitude and Latitude names each time you use a function that needs them).

```{r, warning=FALSE,message=FALSE}
plot( arapat )
```

There are other options you can pass to the plot function, see "?plot.data.frame" for more information.  If you need to get more fancy than just a plot, you can do the plotting manually. Lets say I want to plot the different Species in the data set as different colors.  The following are the steps I would use to create some plots coloring different clusters.

1. Find coordinates for each population and keep only the unique ones.
+ Determine the centroid of this area.
+ Request a map tile from Google (this needs internet connections obviously)
+ Turn the tile into a data.frame
+ Create a plot (I favor ggplot2 as a plotting paradigm)

```{r, mapplot, message=FALSE, error=FALSE }
data <- unique( arapat[,c(2,3,6,5)] )
centroid <- apply( data[,3:4], 2, mean )
centroid
map <- population_map(data)
ggmap( map ) + geom_point( aes(x=Longitude, y=Latitude, color=Cluster), data=data, size=4 )
```







## Allele Frequencies

Another object made easily in **gstudio** are objects related to allele frequencies.  Allele frequencies are just like every other kind of data and can be extracted from a `data.frame` containing `locus` objects using the function `frequencies()`.  

### Single Locus

Grabbing alllele frequencies is a fundamental task for any population genetic analysis and should be as easy as possible.  Here are some examples of various ways to get allele frequency information using the *Araptus attenuatus* data set.


```{r, singleLocus }
freq.EF <- frequencies( arapat$EF )
class( freq.EF)
freq.EF
```

Quick population genetic parameters related to heterozygosity are also easily accessed.

```{r}
Ho( arapat$EF )
He( arapat$EF )
Fis( arapat$EF )
```




### Multilocus

The conversion of loci to a `data.frame` expands beyond the single locus. If you do not specify which locus to use, it will use all `locus` objects and add an additional column to the data frame (n.b., I only print out the first 10 rows to give you the idea).

```{r, multilocusFreqs}
freqs.loci <- frequencies( arapat )
freqs.loci[1:10,]
```


### Substrata and Allele Frequencies

To complete the symmetry here, adding stratum to the analysis, provides yet another categorical variable upon which allele frequencies may be estimated.  Here is an example looking at the "Cluster" strata in the data set and a partial printout of the results.

```{r, strataFreqs }
freqs.strata <- frequencies( arapat, stratum="Cluster" )
freqs.strata[1:10,]
```


### Plotting Allele Frequencies

There are several ways you may want to graphically view the locus data and for convienence, the **gstudio**  package provides some interfaces for nice plots using the *ggplot2* package.  

Plotting a vector of loci will by default estimate the frequencies of each allele for graphical output.  There are two different output for this (n.b., a pie chart by its nature can lead to inaccurate interpretations and most statisticians hate them).

```{r}
plot( arapat$MP20 )
plot( arapat$MP20, mode="pie")
```



The frequencies across a collection of loci can easily be plot just as well (internally, this simple plot is just turns the object into a data frame and then plots it). At times, examination of allele spectra can reveal blantant differnces in substratum of your data.  For example, consider the following spectrum for the locus MP20.


```{r}
f <- freqs.strata[ freqs.strata$Locus %in% c("MP20","AML"), ]
plot_frequencies(f)
```




### Frequency Gradients

When you have many strata or you are conducting landscape-level analyses, it is often helpful to look at how allele frequencies change in relation to some variable other than stratum.  


```{r}
baja <- arapat[ arapat$Species != "CladeB",]
```

The `EN` locus has a few different alleles but if we look at the frequencies of each, the first two dominate.

```{r}
plot( baja$EN )
```

Using just the first allele `01`, it is pretty easy to plot the strata frequency as a function of latitude using normal `R` approaches.  To do this, one needs to:

1. Extract the `01` allele frequencies by population.
```{r}
freqs <- frequencies( baja, stratum="Population", loci="EN")
freq.01 <- freqs[ freqs$Allele == "01",]
```
2. Merge this `data.frame` with one containing the coordinates of the populations.
```{r}
coords <- strata_coordinates( baja )
df <- merge( freq.01, coords)
df[1:10,]
```

Now, you can plot the frequencies as either a linear plot (below you will see how to plot these along environmental gradients).

```{r}
ggplot( df, aes(x=Latitude,y=Frequency)) + geom_line(linetype=2) + geom_point(size=4) 
```

This is interesting.  Now, just to 'kick it up a knotch' I'm going to look at the `Cluster` variable.  This is from mtDNA and shows putatively cryptic species.  I'm going to remake the plot above but color the points to indicate the presence of the 'SCBP-A' clade (perhaps another species).  Below I grab add a new column of data to `df` and then make it all 'baja'.  Then I figure out which populations have 'SCBP-A' individuals in it.

```{r}
df$Species <- "Baja"
pops.with.scbp <- as.character(unique(baja$Population[ baja$Cluster=="SCBP-A"]))
df$Species[ df$Stratum %in% pops.with.scbp ] <- "Cape"
```

Then plot it.

```{r}
ggplot( df, aes(x=Latitude,y=Frequency)) + geom_line(linetype=2) + geom_point(size=5, aes(color=Species) ) 
```

I think this leads to some interesting questions about the relationship between potential species differences, where species are guaged by mtDNA, in nuclear allelic diversity.


### Spatial Frequency Plots


It is also possible to plot the data in a spatial context.  Here is an example of how to mix `ggplot` and `ggmap` data and I'll plot the locations as proportional in size to the allele frequency.

```{r, warning=FALSE,message=FALSE}
map <- population_map(baja)
ggmap( map ) + geom_point( aes(x=Longitude, y=Latitude, size=Frequency), data=df)
```

There is also the option to make use of some pie charts.  I know, pie charts suck and any statistician will tell you that they should probably not be used because they can be misleading, but here they are.  For exploratory data analysis, they can be very insightful at times.  Here is the frequency of alleles at the *enolase* locus in *Araptus*.  Any spatial structuring catch your eye?

```{r,warning=FALSE,message=FALSE}
pies_on_map( arapat, stratum="Population", locus="EN")
```



## Multivariate Analogs

Genotype data is inheriently multivariate.  In fact, it is multinomial multivarite *senus stricto* but we generally ignore that. That being said, we can easily translate raw genotypes into raw multivariate encodings for other statistical analyses.  Here is a quick example using a few individuals and the `WNT` locus.

```{r}
to_mv( arapat$WNT[1:10]  )
to_mv( arapat$WNT[1:10], drop.allele=TRUE)
```


For multiple loci, we can use the same apporach.  Here is an example of a PCA analysis done on raw genotypes.

```{r}
x <- to_mv( arapat, drop.allele=TRUE)
fit.pca <- princomp(x, cor=TRUE)
summary(fit.pca)
```

Interesting.  It takes several eigenvectors to explain these data sufficiently.  Here is a simple plot of some of model, given by computing the predicted values for each sample.  I then use **ggplot** to make a scatter plot with clade dictating the shape of the symbol (each symbol is an individual and clade was determined by mtDNA, not these data), and Clade to provide the color.

```{r}
pred <- predict( fit.pca)
df <- data.frame( PC1=pred[,1], PC2=pred[,2], Species=arapat$Species, Clade=arapat$Cluster, Pop=arapat$Population)
ggplot( df ) + geom_point( aes(x=PC1,y=PC2,shape=Species,color=Clade), size=3, alpha=0.75)
```

Looks like there are three main groups divided by clade and within the more dense clade, there is some substructuring.  I'll take the data that is in the main clade and do a quick heirarchical clustering analysis.

```{r,fig.width=12}
baja <- pred[df$Species=="CladeC",]
h <- hclust( dist( baja ), method="single")
plclust(h,main="Main Baja California Clade")
```


Lets make it just a little better by coloring the leaves by population.

```{r}
pops <- as.numeric(df$Pop[ df$Species=="CladeC"])
```


## Genetic Diversity



### Rarefraction



### Inbreeding




## Genetic Distance


There are several genetic distances available within the **gstudio** package and the ability to use multivariate analogs of genotypes opens up all distance essentially all distance metrics to the end user.  In the stuff that follows are the distances that are internally implemented in the pacakge along with a brief overview.



### Individual Distances

At the base level, you can estimate distances among individuals resulting in an $NxN$ matrix of pair-wise distances.  This is internally how the AMOVA anlaysis is conducted and is a nice heuristic for conceptual understanding of variance decomposition.  


#### AMOVA Distance




#### Bray Curtis Individual Distance








### Strata Distances


#### Euclidean Distance


#### Cavalli-Sforza Distance

\[
D_{CS,m,n} =  \frac{2}{\pi}\sqrt{ 2 * 1-\sum_{i=1}^{\ell} p_{m,i}*p_{n,i}}
\]

#### Jaccard Distance



#### Conditional Genetic Distance (cGD; Graph Distance)


#### Nei's Genetic Distance







## Genetic Structure



### Structural Parameters




### Statistical Differences




## Population Graphs






## References


