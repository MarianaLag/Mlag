<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{An general vignette for gstudio}
-->

<link href="style.css" rel="stylesheet"></link>

```{r css}
options(markdown.HTML.stylesheet = system.file('doc', 'style.css', package='gstudio'))
```

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(out.extra='style="display:block; margin: auto"', fig.align="center")
```



# An Introduction to the **gstudio** Package


## Package Overview

The **gstudio**  package is a package created to make the inclusion of marker based population genetic data in the R workflow easy.  An underlying motivation for this package is to provide a link between spatial analysis and graphing packages such that the user can be quickly and easily manipulate data in exploratory ways that aid in gaining biological inferences.



---

## Installing the package

This package requires several other packages for installation.  By default, the install should be easily accomplished using the build-in functionalities in R.

```{r, eval=FALSE,echo=TRUE}
install.packages("gstudio")
```

Occassionally, you should look to see if there are updates to the package by doing the following (this will update all packages you have installed)

```{r, eval=FALSE}
update.packages( ask=FALSE )
```


### Loading the Package

And any time you need to use the package, you would just pull it into your session.

```{r,message=FALSE}
require(gstudio, quietly=TRUE)
```

This should get you everything you need. The **gstudio**  package does contain a lot of build-in documentation including a lot of examples.  All the functions and examples associaed with them can be found in the build-in documents available from:

```{r, eval=FALSE}
help(package="gstudio", help_type = 'html')
```

At any point if you have any questions about the values or options for a particular function in **gstudio**  or any other package, you can use the  *help.search(func)* or *?* functionality.This file is also kept in sync with the development of the **gstudio**  package (it is in the source packge that you downloaded from CRAN) and will serve as a tutorial for your use of this package.  If there are any questions that you may have regarding this package, feel free to contact [Rodney Dyer](mailto://rjdyer@vcu.edu) and I will get back to you as soon as possible.
















---

## Genetic Data 

The overriding philosophy behind the **gstudio**  package is to make it as easy as possible to create, load, use, and integrate, genetic marker data into your analysis workflow.  As such, we typically use *data.frame* objects to hold our data and the addition of the `locus` class as a fundamental data type allows us to continue to do so.

```{r}
x <- locus( c(1,2) )
class(x)
x
```


You can think of a *locus* object as a vector of alleles.  There are several options you can use when constructing a *locus* object based upon what kind of marker data you are using.  These options are passed through the `type` option to the `locus()` function.  Here are the current options.

`type` Option | Function
------------- | ---------
              | This is the default value (e.g., nothing passed). It will treat the values passed to locus as alleles to a single locus
`snp`         | Alleles are `0`, `1`, or `2` indicating the number of minor alleles.
`zyme`        | Genotypes are encoded as "12" like zymes (e.g., "1" & "2" alleles together).
`separated`   | Alleles are already separated by ":" character (for putting in polyploid data)
`column`      | Alleles for a single locus are in two separate columns.

Here is some examples.

```{r}
loc0 <- locus( )
loc1 <- locus( 1 )
loc2 <- locus( c("C","A"), phased=TRUE )
loc3 <- locus( c("C","A") )
loc4 <- locus( 12, type="zyme" )
loc5 <- locus( 1:4 )
loc6 <- locus( "A:C:C:G", type="separated" )
loci <- c(loc0, loc1, loc2, loc3, loc4, loc5, loc6 )
loci
```

Notice how the printing of each `locus` object uses the colon character to separate alleles.  Also, since the `locus` object is a basic data type, it can be used in other data structures.

```{r}
df <- data.frame( ID=0:6, Loci=loci )
df
```

And you can use normal vector processing of the locus vector to do normal R data like operations.

```{r}
is.na( df$Loci )
is.heterozygote( df$Loci )
```



### Saving and Loading Data

Saving data once it is in R is trivial and you do it as you would for any other R object.  The R object system knows how to serialize its own data using the *load()* and *save()* functions.

```{r,eval=FALSE}
save(df, file="MyData.rda")
```

To load the objects back into the workspace, you just do:

```{r,eval=FALSE}
load("MyData.rda")
```

And you can verify that you have data in your workspace by listing it.

```{r}
ls()
```





### Importing Data

Importing data is not that difficult.  People tend to keep their data in spreadsheets or text files, which are easily accessable via R.  For genetic marker data **gstudio**  has a particular function, *read.population()* that is a mix between the traditional *read.table()* function and the *locus()* functions.  Options for this function include:

Option        |    Function
------------- | --------------
path          | The full path to the text file
type          | The locus `type` (see above).
locus.columns | A vector of numbers of columns to be treated as *Locus()* objects
sep           | The character used to separate columns (',' is default)
header        | Columns have header names (e.g., locus names, etc.)

Here are some examples of data files with different kinds of genetic data, each of which exercises the `read.population()` function in a different way.  Hopefully this covers the main types of data being imported, if not, drop me an email [Rodney Dyer](rjdyer@vcu.edu).  Missing genotypes should be missing data or encoded as `NA`.  If you do not have a genotype then leave it blank.  There is no reason to use negative numbers or other conventions.  

Columns of genotypes are indicated by the required parameter `locus.columns` so that `read.population()` knows which columns to treat as `locus` objects and which to leave as normal data for R.  Without this parameter, the data will be read in as `character` or `numeric`.

There are some example data files included in the project for you to look at. Depending upon how your computer is set up, they may be placed in different locations.  Here is a quick way to find out where the installed folder is for the **gstudio** package and the location of the 'data' folder within it.

```{r}
system.file("extdata",package="gstudio")
```


#### Two Column Data

Here is an example of data where the genotypes are encoded as two columns of data in a csv file.  

```{r}
file <- system.file("extdata","data_2_column.csv",package="gstudio")
data <- read.population(file,type="column", locus.columns=4:7)
data
```


#### Phased Data

There are times when the gametic phase of the genotypes is important.  By default, **gstudio** will keep alleles sorted in alpha/numeric order.  If you need to keep this from happening, pass the optional `phased` option to `read.population()`.  Notice the differences between this and the previous genotypes.

```{r}
file <- system.file("extdata","data_2_column.csv",package="gstudio")
data <- read.population(file,type="column", locus.columns=4:7, phased=TRUE)
data
```




#### AFLP-like data

Genotypes that are 'aflp'-like are encoded as binary characters (e.g., 0/1) indicating the presence or absence of a paraticular band.  

```{r}
file <- system.file("extdata","data_aflp.csv",package="gstudio")
data <- read.population(file,type="aflp", locus.columns=c(4,5))
data
```


#### SNP Minor Allele Data

At times, SNP data is encoded in relation to the number of minor alleles.  You can import these data using the `type="snp"` option and it will encode them as 'AA', 'AB', or 'BB' with the 'B' allele as the minor one.

```{r}
file <- system.file("extdata","data_snp.csv",package="gstudio")
data <- read.population(file,type="snp", locus.columns=4:7)
data
```

#### Zyme-Like Data

Some data is encoded as allozyme genotypes (e.g., 33, 35, 55 for dipoid individuals with alleles '3' and '5').

```{r}
file <- system.file("extdata","data_zymelike.csv",package="gstudio")
data <- read.population(file,type="zyme", locus.columns=4:7)
data
```



#### Pre-Separated Data For Higher Ploidy

```{r}
file <- system.file("extdata","data_separated.csv",package="gstudio")
data <- read.population(file,type="separated", locus.columns=c(4,5))
data
```





### Datasets in the Package

The main genetic data included with the package if from the Sonoran desert bark beetle, *Araptus attenuatus* from the Dyer laboratory.  You can load it into your workspace by:


```{r}
data(arapat)
summary(arapat)
```

You can see several things here.  First, the locus data are displayed by genotype counts including NA values where there was missing data.  A column of type `locus` is just like any other kind of variable and can be used as such.  This opens up a lot of functionality for you to be able to treat marker data just like everything else in R.

### Convenience Functions

Dealing easily with parts of your data is a critical skill and a huge benefit in using a grammar like R to do your analyses.  In R, *data.frame* objects are almost like little databases and you can do some really creative manipulations with them. The **gstudio**  package provides a few things that may help you work more efficiently with your data.



#### Data Classes

Often it is important to know which columns of a data set are actually of a particular data type.  Here is a simple function that tells you either the name or index of columns in a data.frame that of a specific data type.

```{r}
column_class( arapat, class="locus")
column_class( arapat, class="locus", mode="index" )
```








--

## Partitioning

The *Partition()* function takes a data frame and returns a list of data frames, partitioned by the stratum you pass to it.  This is really nice if you are doing a nested analysis of sorts and want to work with subsets of your data that are defined by a categorical *factor* variable.

```{r}
names(arapat)
clades <- partition( arapat, stratum="Species")
names( clades )
```

This kind of partitioning is very common in the analysis of spatial genetic stucture and as such should be as simple as possible to provide the most flexibility to you, the analyst.  One of the common analysis patterns that you will come back to over and over again is to partition the entire data set and perform operations on each of the subgroups.  In **R** this is a pretty easy process if you look into the *lapply()* function (and its relatives).  This is such an important component, that I'm going to spend a little time here to make sure you understand what I am doing.  Once you get it, it will make you life tremendously more awesome!

The basic form of the various 'apply' functions is that you pass them some data and a function on which it will take each part of that data and apply it.  For lists (the *l* part in *lapply()*), the function will take each entry in the list and pass it along to the function.  The function itself can be one that is already available (like *length()* or *is.na()* or something) or it can be something you specify directly, on the fly.  Here is an example looking at the number of samples in each 'Species' as partitioned above.

```{r}
lapply( clades, dim)
```

Here the *dim()* function returns the dimension of the data.frame in each clade, all have the same number of columns, but differ in the number of individuals (the rows).  While this is a stupid example (you could get the same thing from *dim(arapat$Species*) but it shows the general pattern.  

Where these functions come in handy is in creating your own functions.   These can be small functions that do something specific and can be shoved into the *lapply()* function directly.  This gives a lot of leeway in what you can do in R and is a very powerful way of understanding data.  Here is an example, say we want to know the number of individuals of each "Species" found in each population (some are in sympatry in the Cape Region of Baja California).  The general approach will be:

1. Partition on population
+  Make a table of Species counts for each population.
+  Take resulting list and turn it into a matrix (use the *unlist()* function) with three columns (the *byrow=TRUE* is key here)
+  Add row and column labels

```{r}
pops <- partition( arapat, stratum="Population")
counts <- lapply( pops, function(x) { return (table(x$Species) ) } )
m <- matrix( unlist( counts), ncol=3, byrow=TRUE )
rownames(m) <- names(pops)
colnames(m) <- levels( arapat$Species )
m[1:10,]
```

(only the first 10 rows are displayed).  You will see this kind of use of the *lapply()* throughout the rest of this document.












---

## Plotting Populations

One of the key benefits to using an analysis environtment such as R is that you can mash together functionality that you just can't get from a monolithic program.  An example of this is plotting populations.  If your data has spatial coordinates in them then you can use this to plot the location of your sites on a GoogleMap tile.  By default, you **must** have your coordinates in decimal degree format.  This is the default for the GoogleMaps API.  Moreover, if you name the columns of data "Longitude" and "Latitude" much of the spatial functionality in **gstudio** will be more transparent (if not, you have to specify the Longitude and Latitude names each time you use a function that needs them).

```{r, warning=FALSE,message=FALSE}
plot( arapat )
```

There are other options you can pass to the plot function, see "?plot.data.frame" for more information.  If you need to get more fancy than just a plot, you can do the plotting manually. Lets say I want to plot the different Species in the data set as different colors.  The following are the steps I would use to create some plots coloring different clusters.

1. Find coordinates for each population and keep only the unique ones.
+ Determine the centroid of this area.
+ Request a map tile from Google (this needs internet connections obviously)
+ Turn the tile into a data.frame
+ Create a plot (I favor ggplot2 as a plotting paradigm)

```{r, mapplot, message=FALSE, error=FALSE }
data <- unique( arapat[,c(2,3,6,5)] )
centroid <- apply( data[,3:4], 2, mean )
centroid
map <- population_map(data)
ggmap( map ) + geom_point( aes(x=Longitude, y=Latitude, color=Cluster), data=data, size=4 )
```










---

## Allele Frequencies

Another object made easily in **gstudio** are objects related to allele frequencies.  Allele frequencies are just like every other kind of data and can be extracted from a `data.frame` containing `locus` objects using the function `frequencies()`.  

### Single Locus

Grabbing alllele frequencies is a fundamental task for any population genetic analysis and should be as easy as possible.  Here are some examples of various ways to get allele frequency information using the *Araptus attenuatus* data set.


```{r, singleLocus }
freq.EF <- frequencies( arapat$EF )
class( freq.EF)
freq.EF
```




### Multilocus

The conversion of loci to a `data.frame` expands beyond the single locus. If you do not specify which locus to use, it will use all `locus` objects and add an additional column to the data frame (n.b., I only print out the first 10 rows to give you the idea).

```{r, multilocusFreqs}
freqs.loci <- frequencies( arapat )
freqs.loci[1:10,]
```


### Substrata and Allele Frequencies

To complete the symmetry here, adding stratum to the analysis, provides yet another categorical variable upon which allele frequencies may be estimated.  Here is an example looking at the "Cluster" strata in the data set and a partial printout of the results.

```{r, strataFreqs }
freqs.strata <- frequencies( arapat, stratum="Cluster" )
freqs.strata[1:10,]
```


### Plotting Allele Frequencies

There are several ways you may want to graphically view the locus data and for convienence, the **gstudio**  package provides some interfaces for nice plots using the *ggplot2* package.  

Plotting a vector of loci will by default estimate the frequencies of each allele for graphical output.  There are two different output for this (n.b., a pie chart by its nature can lead to inaccurate interpretations and most statisticians hate them).

```{r}
plot( arapat$MP20 )
plot( arapat$MP20, mode="pie")
```



The frequencies across a collection of loci can easily be plot just as well (internally, this simple plot is just turns the object into a data frame and then plots it). At times, examination of allele spectra can reveal blantant differnces in substratum of your data.  For example, consider the following spectrum for the locus MP20.


```{r}
f <- freqs.strata[ freqs.strata$Locus %in% c("MP20","AML"), ]
plot_frequencies(f)
```




### Frequency Gradients

When you have many strata or you are conducting landscape-level analyses, it is often helpful to look at how allele frequencies change in relation to some variable other than stratum.  


```{r}
baja <- arapat[ arapat$Species != "CladeB",]
```

The `EN` locus has a few different alleles but if we look at the frequencies of each, the first two dominate.

```{r}
plot( baja$EN )
```

Using just the first allele `01`, it is pretty easy to plot the strata frequency as a function of latitude using normal `R` approaches.  To do this, one needs to:

1. Extract the `01` allele frequencies by population.
```{r}
freqs <- frequencies( baja, stratum="Population", loci="EN")
freq.01 <- freqs[ freqs$Allele == "01",]
```
2. Merge this `data.frame` with one containing the coordinates of the populations.
```{r}
coords <- strata_coordinates( baja )
df <- merge( freq.01, coords)
df[1:10,]
```

Now, you can plot the frequencies as either a linear plot (below you will see how to plot these along environmental gradients).

```{r}
ggplot( df, aes(x=Latitude,y=Frequency)) + geom_line(linetype=2) + geom_point(size=4) 
```

This is interesting.  Now, just to 'kick it up a knotch' I'm going to look at the `Cluster` variable.  This is from mtDNA and shows putatively cryptic species.  I'm going to remake the plot above but color the points to indicate the presence of the 'SCBP-A' clade (perhaps another species).  Below I grab add a new column of data to `df` and then make it all 'baja'.  Then I figure out which populations have 'SCBP-A' individuals in it.

```{r}
df$Species <- "Baja"
pops.with.scbp <- as.character(unique(baja$Population[ baja$Cluster=="SCBP-A"]))
df$Species[ df$Stratum %in% pops.with.scbp ] <- "Cape"
```

Then plot it.

```{r}
ggplot( df, aes(x=Latitude,y=Frequency)) + geom_line(linetype=2) + geom_point(size=5, aes(color=Species) ) 
```

I think this leads to some interesting questions about the relationship between potential species differences, where species are guaged by mtDNA, in nuclear allelic diversity.





### Spatial Frequency Plots

It is also possible to plot the data in a spatial context.  Here is an example of how to mix `ggplot` and `ggmap` data and I'll plot the locations as proportional in size to the allele frequency.

```{r, warning=FALSE,message=FALSE}
map <- population_map(baja)
ggmap( map ) + geom_point( aes(x=Longitude, y=Latitude, size=Frequency), data=df)
```

There is also the option to make use of some pie charts.  I know, pie charts suck and any statistician will tell you that they should probably not be used because they can be misleading, but here they are.  For exploratory data analysis, they can be very insightful at times.  Here is the frequency of alleles at the *enolase* locus in *Araptus*.  Any spatial structuring catch your eye?

```{r,warning=FALSE,message=FALSE}
pies_on_map( arapat, stratum="Population", locus="EN")
```
















---

## Multivariate Analogs for Loci

Genotype data is inheriently multivariate.  In fact, it is multinomial multivarite *senus stricto* but we generally ignore that. That being said, we can easily translate raw genotypes into raw multivariate encodings for other statistical analyses.  Here is a quick example using a few individuals and the `WNT` locus.

```{r}
to_mv( arapat$WNT[1:10]  )
to_mv( arapat$WNT[1:10], drop.allele=TRUE)
```


For multiple loci, we can use the same apporach.  Here is an example of a PCA analysis done on raw genotypes.

```{r}
x <- to_mv( arapat, drop.allele=TRUE)
fit.pca <- princomp(x, cor=TRUE)
summary(fit.pca)
```

Interesting.  It takes several eigenvectors to explain these data sufficiently.  Here is a simple plot of some of model, given by computing the predicted values for each sample.  I then use **ggplot** to make a scatter plot with clade dictating the shape of the symbol (each symbol is an individual and clade was determined by mtDNA, not these data), and Clade to provide the color.

```{r}
pred <- predict( fit.pca)
df <- data.frame( PC1=pred[,1], PC2=pred[,2], Species=arapat$Species, Clade=arapat$Cluster, Pop=arapat$Population)
ggplot( df ) + geom_point( aes(x=PC1,y=PC2,shape=Species,color=Clade), size=3, alpha=0.75)
```

Looks like there are three main groups divided by clade and within the more dense clade, there is some substructuring.  I'll take the data that is in the main clade and do a quick heirarchical clustering analysis.

```{r,fig.width=12}
baja <- pred[df$Species=="CladeC",]
h <- hclust( dist( baja ), method="single")
plclust(h,main="Main Baja California Clade", xlab="")
```



















---

## Measures of Genetic Diversity

Genetic diversity is estimated by several different means.  It can be estiamted at several different levels; at individuals, at groups, at populations, etc.  It can also be estimated by several different parameters.  This section covers some of the more common parameters used for quantifying genetic diversity.


### Allelic Diversity

At the most basic level, the number of alleles within a group of individuals is a base measure of diversity.  However, there are some caveats to be made about the way in which we count alleles.  Rare alleles may or may not be as informative.  The three ways commonly used to look at allelic diversity are

1. The total number of alleles ($A$).
2. The effective number of alleles ($A_e$).
3. The number of alleles with at least 5% frequency ($A_{95}$).

These parameters are estimated from your data using the **allelic.diversity()** function.  The argument **mode** takes either "A" (the default), "Ae", or "A95" to differentiate.

```{r}
AA <- locus( c("A","A") )
AB <- locus( c("A","B") )
loci <- c(AA,AB,AA,AA,AA,AA,AA,AA,AA,AA,AA)
loci
allelic.diversity(loci)
allelic.diversity(loci,mode="Ae")
allelic.diversity(loci,mode="A95")
```


#### Rarefaction

Rarefaction is a technique used to measure diversity in different populations.  It is particularly important for situations where you have different sample sizes.  Is there more diversity in the larger population because you sampled more or is it a truely more diverse population?  I'll use the data from the beetle to show how diversity changes with sample sizes and highlight how you can use the *rarefaction()* function.  

In the mainland populations, there are only 36 samples and the allelic diversity is relatively low at the WNT locus.

```{r}
loci.son <- arapat$WNT[ arapat$Species == "CladeB" ] 
length( loci.son )
allelic.diversity( loci.son, mode="Ae")
```

The larger clade on the peninsula has many more individuals and is more diverse.  

```{r}
loci.baja <- arapat$WNT[ arapat$Species == "CladeC" ]
length( loci.baja )
allelic.diversity( loci.baja, mode="Ae")
```

So is this difference a consequence of the sample sizes or is peninsular Baja California more genetically diverse?  To answer this, rarefaction randomly subsamples the loci.baja data and estimates the value of $\hat{A}_e$ for samples of size 36 (for our case) to see if the observed diversity differences are due to sampling alone.  To visualize the distribution, I throw it into a *data.frame* and use the **ggplot2** functions to make the pretty colored histogram.

```{r warning=FALSE}
Ae.Baja  <- rarefaction(loci.baja, mode="Ae", size=36)
df <- data.frame( Ae.Baja )
ggplot( df, aes(x=Ae.Baja) ) + geom_histogram(aes(fill=..count..)) + scale_fill_gradient("count",low="#cccccc",high="#a60000") + theme_bw()
```



### Heterozygosity

At a base level, heterozygosity is a form of diversity (see Nei).  Heterozygosity can be measured at many different stratum and in two forms.  All of these approaches can be accessed through the functions *Ho()* (for observed heterozygosity)  

```{r}
Ho( arapat$EF )
```

and *He()* (for expected heterozygosity given Hardy Weinberg Equilibrium).

```{r}
He( arapat$EF )
```

Given the broadness of these functions, it is easy to integrate them into broader analyses. Here is an example of expected heterozygosity ($H_E$ or genetic diversity in Nei's terms) as a function of latitude for the peninsular populations.  The output is displayed as a plot.

```{r}
baja <- arapat[ arapat$Species != "CladeB",]
coords <- strata_coordinates(baja)
pops <- partition(baja,stratum="Population")
he <- lapply( pops, function(x) return(He(x$EN, small.sample.correction=TRUE)) ) 
data <- merge( coords, data.frame( Stratum=names(he), He=unlist(he)))
data <- data[ order( data$Latitude), ]
ggplot( data, aes(x=Latitude, y=He)) + geom_line(linetype=2) + geom_point(color="red",size=4)
```













---


## Inbreeding

Inbreeding is a consequence of mating patterns and/or demographic population size.  The consequences of inbreeding are related to how alleles are put into genotypes.  One approach to looking at inbreeding is to estimate the expected frequency of heterozygotes (e.g., the $2pq$ part of the classic Hardy-Weinberg equation) and compare it to the observed level of inbreeding. This is the classic $F$ statistic and is estimated as:

\[
F_{IS} = 1 - \frac{H_{O}}{H_{E}}
\]

Using the beetle data again, from the maps above we see three mainland populations and there is a good reason to believe that these are a separate species (see Garrick *et al.* 2013).  These populations are small and isolated and as such may experience inbreeding.  

```{r}
sonora <- arapat[ arapat$Species == "CladeB",]
fis.sonora <- Fis( sonora )
fis.sonora
```

There are various ways to get a confidence interval on these kind of analyses.  In what follows is an implicit test of $H_O: F_{IS} = 0$ using permuation.  If that Null hypothesis is true, then any random perumation of alleles (combined into genotypes) sampled from this population would produce estimates of $F_{IS}$ as large as that observed.  This kind of permutation is handled by the function *permute_ci()* (though it can be applied to more complicated analysess as shown below).  Here is an example of how to use it to create the null distribution of $F_{IS}$ values given these data.  

For simplicity, I only apply this to the $EN$ locus.

```{r,warning=FALSE}
fis.perm <- permute_ci( sonora$EN, FUN=Fis, nperm=999 )
summary( fis.perm )
```















---

## Measures of Genetic Distance


There are several genetic distances available within the **gstudio** package and the ability to use multivariate analogs of genotypes opens up all distance essentially all distance metrics to the end user.  In the stuff that follows are the distances that are internally implemented in the pacakge along with a brief overview.



### Individual Distances

At the base level, you can estimate distances among individuals resulting in an $NxN$ matrix of pair-wise distances.  This is internally how the AMOVA anlaysis is conducted and is a nice heuristic for conceptual understanding of variance decomposition.  


#### AMOVA Distance

\[
\delta_{ij}^2 = 2(p_i-p_j)^2
\]

#### Jaccard Distance

Jaccard distance is a set-theoretic distance quantifying dissimilarity.  Assuming that loci are sets of alleles, the Jaccard dissimilarity between genotypes $A$ and $B$ is given by:

\[
J_\delta(A,B) = \frac{|A \bigcup B| - |A \bigcap B|}{|A \bigcup B|}
\]

You can look at the elements of the LTRS matrix (it is 36x36 so I am not printing it out here).  With \texttt{mode="Jaccard"}, missing genotypes will result in \texttt{NA} rows and columns in the distance matrix.  It is no entirely clear how this metric can easily handle missing genotypes.



#### Bray Curtis Individual Distance


Bray-Curtis Distance (Bray \& Curtis 1957) has been primarily used to quantify differences in species composition.  It is defined as the total number of species that are unique to either of the two sites standardized by the number of species in both sites.  

\[
BC_\delta = \frac{S_i + S_j - 2S_{ij}}{S_i+S_j}
\]

where $S_x$ is the species count and $S_{ij}$ is the sum of minimum abundances.  Lately, this has seen considerable use within individual-based landscape genetic studies.  Missing genotypes are set to average allele frequencies, that is to say that every missing genotype is considered to have all the alleles present in the entire population, but with probability equal to their global frequencies.  Essentially, this removes the \texttt{NA} problem like in the \texttt{mode="Jaccard"} situation and does so by taking the non-missing genotype's genetic distance from the global genetic centroid (it's cosmic man!).  Here is the estimation using two loci.


### Strata Distances


Genetic distances can also be estimated among groups of individuals.  The same data will be used here but since there are only three populations, we'll be able to see the whole distance matrix. 


#### Euclidean Distance


Euclidean distance is the most straight-forward distance metric available as it is essentially straight-line distance based upon the allele frequencies in each population.  It is given by:

\[
  d_{eucl} = \sqrt{ \sum_{j=1}^L(p_{ij} - p_{kj})^2 }
\]

where $p_{ij}$ and $p_{kj}$ are the frequencies of the $j^{th}$ allele in both the $i^{th}$ and $j^{th}$ population.  In this and the following distance examples, I am going to take the resulting distance matrix among all pairs of populations and put them into a Neighbor joining tree (via the *nj()* function from the *ape* package) as it may be easier to see differences in topologies rather than matrices.

It is perhaps easiest to think of Euclidean distance in x,y coordinate space.  This distance can be estimated by *stratum.distance()* using the optional parameter *method='eucl'* and it will return a *dist* matrix.

Once the matrix has been estimated, you can visualize it in many ways.  One of the most straight-forward approaches it to visualizing the relationships among rows and columns is to put it into a bifurcating tree.  


#### Cavalli-Sforza Distance

Another distance approach that is commonly used for microsatellite loci is Cavalli-Sforza distance, $D_C$ (Cavalli-Sforza and Edwards, 1967).  Here population allele frequencies are plot on the surface of a sphere (radius=1) using the square root of the allele frequencies.  

\[
  D_C = \frac{2}{\pi}\sqrt{(2-2cos\theta)}
\]

The genetic distance, $D_C$ is measured as the chord distance as indicated in Figure.  The resulting Neighbor joining tree from this distance is shown in Figure \ref{fig:cavalli_dist}

\[
D_{CS,m,n} =  \frac{2}{\pi}\sqrt{ 2 * 1-\sum_{i=1}^{\ell} p_{m,i}*p_{n,i}}
\]

#### Jaccard Distance



#### Conditional Genetic Distance (cGD; Graph Distance)


#### Nei's Genetic Distance







## Genetic Structure



### Structural Parameters




### Statistical Differences




## Population Graphs






## References


